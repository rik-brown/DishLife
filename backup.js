/*
 * Step 1 - a very stripped down version
 */

var colony; // A colony object
var colonySize = 100;
var cellStartSize = 20;
var debug = false;

function setup() {
  createCanvas(windowWidth, windowHeight);
  ellipseMode(RADIUS);
  background(128);
  colony = new Colony(colonySize, cellStartSize);
}

function draw() {
  background(128);
  colony.run();
  if (colony.cells.length === 0) {populateColony(); }
}

function populateColony() {
  background(0); // Refresh the background
  colony.cells = [];
  colony = new Colony(colonySize, cellStartSize);
}


/* ------------------------------------------------------------------------------------------------------------- */

// Colony class

// CONSTRUCTOR: Create a 'Colony' object, initially populated with 'num' cells
function Colony(num, cellStartSize_) { // Imports 'num' from Setup in main, the number of Cells in initial spawn
  // Start with an array for all cells
  this.cells = [];

  // VARIABLES

  var colonyMaxSize = 100;

  // Create initial population of cells
  for (var i = 0; i < num; i++) {
    var pos = createVector(random(width), random(height));
    var vel = createVector(0,0); // Initial velocity vector is random
    this.cells.push(new Cell(pos, vel, cellStartSize)); // Add new Cell
  }

  this.spawn = function(pos_, vel_, cellStartSize_) { // Spawn a new cell
    this.cells.push(new Cell(pos_, vel_, cellStartSize_));
  };

  // Run the colony
  this.run = function() {

    if (debug) {this.colonyDebugger(); }

    var target = createVector(mouseX, mouseY);

    // Iterate backwards through the ArrayList because we are removing items
    for (var i = this.cells.length - 1; i >= 0; i--) {
      var c = this.cells[i]; // Get one cell at a time
      c.seek(target);
      c.run(); // Run it (grow, move, spawn, check position vs boundaries etc.)






      if (c.dead()) {this.cells.splice(i, 1); // If cell has died, remove it from the array
      }

      // Iteration to check collision between current cell(i) and the rest
      if (this.cells.length <= colonyMaxSize) { // Don't check for collisons if there are too many cells (wait until some die off)
        if (c.fertile) { //Only do the check on cells that are fertile
          for (var others = i - 1; others >= 0; others--) { // Since main iteration (i) goes backwards, this one needs to too
            var other = this.cells[others]; // Get the other cells, one by one
            if (other.fertile) {c.checkCollision(other);} // Only check for collisions when both cells are fertile
          }
        }
      }
    }

    // If there are too many cells, remove some by 'culling' (not actually active now, functional code is commented out)
    if (this.cells.length > colonyMaxSize) {
      this.cull(colonyMaxSize);
    }
  };

  this.cull = function(div) { // To remove a proportion of the cells from (the oldest part of) the colony
    var cull = (this.cells.length / div);
    for (var i = cull; i >= 0; i--) { this.cells.splice(i,1); }
    //background(0);                    // Use this to clear the background on cull
    //fill(255, 1);                     // Use this to veil the background on cull
    //rect(-1, -1, width+1, height+1);
  };

  this.colonyDebugger = function() { // Displays some values as text at the top left corner (for debug only)
    fill(0);
    rect(0,0,300,20);
    fill(360, 100);
    textSize(16);
    text("Nr. cells: " + this.cells.length + " MaxLimit:" + colonyMaxSize, 10, 20);
  };
}

/* ------------------------------------------------------------------------------------------------------------- */

// cell Class
function Cell(pos, vel, cellStartSize_) {

  // BOOLEAN
  this.fertile = false; // A new cell always starts of infertile

  // GROWTH & REPRODUCTION
  this.age = 0; // Age is 'number of frames since birth'. A new cell always starts with age = 0. What is it used for?
  this.lifespan = 1000;
  this.fertility = 0.6;
  this.spawnCount = 3;

  // SIZE AND SHAPE
  this.cellStartSize = cellStartSize_;
  this.cellEndSize = 0.5;
  this.r = this.cellStartSize; // Initial value for radius
  this.size = map(this.r, this.cellStartSize, this.cellEndSize, 1, 0);
  this.flatness = 1.3;
  this.growth = (this.cellStartSize-this.cellEndSize)/this.lifespan;

  // MOVEMENT
  this.position = pos; //cell has position
  this.velocity = vel; //cell has unique basic velocity component
  this.acc = createVector(0,0);
  this.vMax = 2; //Maximum magnitude in velocity components generated by noise
  this.xoff = random(1000); //Seed for noise
  this.yoff = random(1000); //Seed for noise
  this.step = 0.006; //Step-size for noise
  this.maxspeed = 5;
  this.maxforce = 0.2;


  this.run = function() {
    this.live();
    this.updatePosition();
    this.updateSize();
    this.updateFertility();
    this.checkBoundaryWraparound();
    this.display();
    if (debug) {this.cellDebugger(); }
  }

  this.live = function() {
    this.age += 1;
    this.maturity = map(this.age, 0, this.lifespan, 1, 0);
  }

  this.applyForce = function(force) {
      this.acc.add(force);
    }

  this.updatePosition = function() {
    // var vx = map(noise(this.xoff), 0, 1, -this.vMax, this.vMax); // get new vx value from Perlin noise function
    // var vy = map(noise(this.yoff), 0, 1, -this.vMax, this.vMax); // get new vy value from Perlin noise function
    // this.velocity = createVector(vx, vy); // create new velocity vector based on new vx, vy components
    // this.xoff += this.step; // increment x offset for next vx value
    // this.yoff += this.step; // increment x offset for next vy value
    this.velocity.add(this.acc);
    this.velocity.limit(this.maxspeed);
    this.position.add(this.velocity);
    this.acc.set(0, 0);
  }

  this.updateSize = function() { //Alternatively: cell is always growing, so include this in 'living' but allow for growth=0 ??
    this.r -= this.growth; // Cell can only shrink for now
    this.size = map(this.r, this.cellStartSize, this.cellEndSize, 1, 0);
  }

  this.updateFertility = function() {
    if (this.maturity <= this.fertility) {this.fertile = true; } else {this.fertile = false; } // A cell is fertile if maturity is within limit (a % of lifespan)
    if (this.spawnCount == 0) {this.fertility = 0;} // Once spawnCount has counted down to zero, the cell will spawn no more
  }

  this.checkBoundaryWraparound = function() {
    if (this.position.x > width + this.r*this.flatness) {
      this.position.x = -this.r*this.flatness;
    } else if (this.position.x < -this.r*this.flatness) {
      this.position.x = width + this.r*this.flatness;
    } else if (this.position.y > height + this.r*this.flatness) {
      this.position.y = -this.r*this.flatness;
    } else if (this.position.y < -this.r*this.flatness) {
      this.position.y = height + this.r*this.flatness;
    }
  }
  this.seek = function(target) {
    var desired = p5.Vector.sub(target, this.position);

    // The seek behavior!
    desired.setMag(this.maxspeed);

    // Steering formula
    var steering = p5.Vector.sub(desired, this.vel);
    steering.limit(this.maxforce);
    this.applyForce(steering);
  }


  // Death
  this.dead = function() {
    if (this.size <= 0) {return true;} // Size = 0 when r = cellEndSize
    if (this.age >= this.lifespan) {return true;} // Death by old age (regardless of size, which may remain constant)
    if (this.position.x > width + this.r*this.flatness || this.position.x < -this.r*this.flatness || this.position.y > height + this.r*this.flatness || this.position.y < -this.r*this.flatness) {return true;} // Death if move beyond canvas boundary
    else {return false; }
  };


  this.display = function() {
    noStroke();
    fill(255);
    var angle = this.velocity.heading();
    push();
    translate(this.position.x, this.position.y);
    rotate(angle);
    if (this.fertile) {
      fill(0); ellipse(0, 0, this.r, this.r * this.flatness);
      }
    else {
      fill(255); ellipse(0, 0, this.r, this.r * this.flatness);
      }
    pop();
  }

  this.checkCollision = function(other) { // Method receives a Cell object 'other' to get the required info about the collidee
    var distVect = p5.Vector.sub(other.position, this.position); // Static vector to get distance between the cell & other
    var distMag = distVect.mag(); // calculate magnitude of the vector separating the balls
    if (distMag < (this.r + other.r)) {this.conception(other, distVect);} // Spawn a new cell
  }



  this.conception = function(other, distVect) {
    // Decrease spawn counters.
    this.spawnCount--;
    other.spawnCount--;

    // Calculate position for spawn based on PVector between cell & other (leaving 'distVect' unchanged, as it is needed later)
    this.spawnPos = distVect.copy(); // Create spawnPos as a copy of the (already available) distVect which points from parent cell to other
    this.spawnPos.normalize();
    this.spawnPos.mult(this.r); // The spawn position is located at parent cell's radius
    this.spawnPos.add(this.position);

    // Calculate velocity vector for spawn as being centered between parent cell & other
    this.spawnVel = this.velocity.copy(); // Create spawnVel as a copy of parent cell's velocity vector
    this.spawnVel.add(other.velocity); // Add dad's velocity
    this.spawnVel.normalize(); // Normalize to leave just the direction and magnitude of 1 (will be multiplied later)

    // Call spawn method (in Colony) with the new parameters for position, velocity, colour & starting radius)
    colony.spawn(this.spawnPos, this.spawnVel, this.r);

    //Reset fertility counter
    this.fertility *= this.fertility;
    other.fertility *= other.fertility;
  }

  this.cellDebugger = function() { // Displays cell parameters as text (for debug only)
    var rowHeight = 15;
    fill(255);
    textSize(rowHeight);
    // RADIUS
    //text("r:" + this.r, this.position.x, this.position.y + rowHeight*1);
    //text("cellStartSize:" + this.cellStartSize, this.position.x, this.position.y + rowHeight*2);
    //text("cellEndSize:" + this.cellEndSize, this.position.x, this.position.y + rowHeight*3);

    // COLOUR
    //text("fill_H:" + this.fill_H, this.position.x, this.position.y + rowHeight*4);
    //text("fill_Htw:" + this.fill_Htwisted, this.position.x, this.position.y + rowHeight*5);
    //text("fill_S:" + this.fill_S, this.position.x, this.position.y + rowHeight*6);
    //text("fill_B:" + this.fill_B, this.position.x, this.position.y + rowHeight*7);
    //text("this.fillCol:" + this.fillColor, this.position.x, this.position.y + rowHeight*2);
    //text("this.fillAlpha:" + this.fillAlpha, this.position.x, this.position.y + rowHeight*3);
    //text("this.fillCol (hue):" + hue(this.fillColor), this.position.x, this.position.y + rowHeight*2);
    //text("this.strokeCol:" + this.strokeColor, this.position.x, this.position.y + rowHeight*4);
    //text("this.strokeAlpha:" + this.strokeAlpha, this.position.x, this.position.y + rowHeight*5);

    // GROWTH
    //text("size:" + this.size, this.position.x, this.position.y + rowHeight*0);
    //text("growth:" + this.growth, this.position.x, this.position.y + rowHeight*5);
    text("maturity:" + this.maturity, this.position.x, this.position.y + rowHeight*1);
    text("lifespan:" + this.lifespan, this.position.x, this.position.y + rowHeight*0);
    //text("age:" + this.age, this.position.x, this.position.y + rowHeight*3);
    text("fertility:" + this.fertility, this.position.x, this.position.y + rowHeight*2);
    //text("fertile:" + this.fertile, this.position.x, this.position.y + rowHeight*3);
    //text("spawnCount:" + this.spawnCount, this.position.x, this.position.y + rowHeight*4);

    // MOVEMENT
    //text("vel.x:" + this.velocity.x, this.position.x, this.position.y + rowHeight*4);
    //text("vel.y:" + this.velocity.y, this.position.x, this.position.y + rowHeight*5);
    //text("vel.heading():" + this.velocity.heading(), this.position.x, this.position.y + rowHeight*3);
  }

}
